# StatefulMenu — Руководство (RU)

## Обзор
Минималистичная библиотека для построения «состоящих из экранов» консольных меню: стековая навигация, хоткеи, локализация и безопасный ввод.

- Провайдеры экранов и команды
- Хоткеи, стрелки, выбор по цифрам (многозначный), Esc=Назад, нулевой пункт (0)
- Ввод моделей: атрибуты, валидаторы, конвертеры, enum
- Локализация (ru/en)
- DI-расширение и авто‑сканирование провайдеров/команд

## Быстрый старт
- Зарегистрируйте сервисы и запустите навигацию от корневого провайдера.
- Реализуйте `IMenuProvider`, возвращающий `MenuState` с `MenuItem`.

## Провайдеры и команды
- Каждый экран — `IMenuProvider`.
- Команды (`IMenuCommand`) инкапсулируют действия.
- Пункты из команд: `new MenuItem(cmd.Title, _ => cmd.ExecuteAsync(ct))`.

## Навигация
`MenuResult.None/Push/Replace/Pop/Exit`

## Ввод данных
- `[InputField]` на свойствах
- `[InputModel("Заголовок")]` на типе для кастомного заголовка формы

## Нулевой пункт (0)
- Хелперы: `MenuItem.Back()/Exit()`.
- Обратная совместимость: добавьте `BackCommand/ExitCommand/HomeCommand` — рендерер сам сделает их нулевыми (0), без `MenuItem.Back()`.
- Нажатие `0` сразу выполняет нулевой пункт; стрелками его можно выбрать.

## Скрытые пункты
- `MenuItem.Hidden(...)` — не отображается и не участвует в цифровом выборе; хоткеи работают.

## Хэдер и компоновка
- `MenuHeaderOptions { Separator, Segments }`
- Если `Header` задан, `Title` переносится в первую ячейку хедера, строка `=== Title ===` не печатается.

## Длинные списки и выбор
- Вьюпорт держит выделенный пункт по центру, выводит `...` при обрезке.
- Поддерживается многозначный ввод (например, 12 + Enter).

## DI-сканирование
- `services.AddStatefulMenu()` сканирует вызывающую сборку на провайдеры/команды.

## Пример
См. `temp/ClinicDemo` — полный пример архитектуры провайдеров/команд.
